scalar UUID

scalar Any

scalar Time

scalar Cursor

directive @authzByPolicy(policy: POLICY) on FIELD_DEFINITION

directive @authenticated on FIELD_DEFINITION

directive @extraStructTag on FIELD_DEFINITION

enum POLICY {
  SERVICE_TOKEN
  NONE
}

enum FEATURE {
  DISCORD_ACCESS
  ALPHA_ACCESS
  BETA_ACCESS
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: Cursor
  endCursor: Cursor
}

type User {
  id: UUID!
  email: String!
  duoLogin: String!
  duoID: Int!
  firstName: String!
  usualFirstName: String
  lastName: String!
  Phone: String
  PoolYear: String
  PoolMonth: String
  Nickname: String
  AvatarURL: String
  CoverURL: String
  accounts: [Account]
  features: [FEATURE!]!
  currentLocation: Location
  isFollowing: Boolean!
  isFollower: Boolean!
  following: [User]!
  followers: [User]!
}

type Account {
  id: UUID!
  type: String!
  provider: String!
  providerAccountId: String!
  username: String!
  expires_at: Int
  token_type: String
  refresh_token: String @authzByPolicy(policy: SERVICE_TOKEN)
  access_token: String @authzByPolicy(policy: SERVICE_TOKEN)
  scope: String
  userID: UUID!
  user: User!
}

type Campus {
  id: UUID!
  name: String!
  active: Boolean!
  timeZone: String!
  languageCode: String!
  country: String
  city: String
}

type Location {
  id: UUID!
  duoID: Int!
  userID: UUID!
  campusID: UUID!
  beginAt: Time!
  endAt: Time
  identifier: String!
  userDuoID: Int
  userDuoLogin: String

  user: User!
  campus: Campus!
}

type LocationConnection {
  totalCount: Int!
  pageInfo: PageInfo!
  edges: [LocationEdge!]!
}

type LocationEdge {
  node: Location
  cursor: Cursor!
}

type Query {
  me: User! @authenticated
  searchUser(query: String!): [User!]! @authenticated

  campus(id: UUID!): Campus @authenticated
  user(id: UUID!): User @authenticated
  location(id: UUID!): Location @authenticated

  locations(page: PageInput!, campusID: UUID!): LocationConnection! @authenticated
  locationsByCampusName(page: PageInput!, campusName: String!): LocationConnection! @authenticated
  locationsByCluster(page: PageInput!, campusName: String!, identifierPrefix: String): LocationConnection! @authenticated

  internalGetUserByAccount(provider: PROVIDER!, uid: String!): User! @authzByPolicy(policy: SERVICE_TOKEN)
  internalGetUserByEmail(email: String!): User! @authzByPolicy(policy: SERVICE_TOKEN)
  internalGetUser(id: UUID!): User! @authzByPolicy(policy: SERVICE_TOKEN)
}

type Mutation {
  createFriendship(userID: UUID!): Boolean! @authenticated
  deleteFriendship(userID: UUID!): Boolean! @authenticated

  internalCreateUser(input: CreateUserInput!): UUID! @authzByPolicy(policy: SERVICE_TOKEN)
  internalLinkAccount(input: LinkAccountInput!): Account! @authzByPolicy(policy: SERVICE_TOKEN)
  inviteOnDiscord: Boolean! @authenticated
}

input PageInput {
  after: Cursor
  first: Int! = 100
  before: Cursor
  last: Int
}

input CreateUserInput {
  email: String!
  duoID: Int!
  duoLogin: String!
  firstName: String!
  usualFirstName: String
  lastName: String!
  poolYear: String
  poolMonth: String
  phone: String
  isStaff: Boolean!
}

input LinkAccountInput {
  provider: PROVIDER
  type: ACCOUNT_TYPE
  providerAccountId: String!
  username: String!
  accessToken: String!
  tokenType: String!
  expiresAt: Int
  refreshToken: String
  scope: String!
  userID: String!
}

enum PROVIDER {
  GITHUB
  DUO
  DISCORD
}

enum ACCOUNT_TYPE {
  OAUTH
}